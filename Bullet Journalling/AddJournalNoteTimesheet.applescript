--
--	Created by: Stephen Schwetz
--	Created on: 05/07/22
--
--	Copyright © 2022 Stephen Schwetz, All Rights Reserved
--
-- Functions
-- AppendNote(theAccount as string, theMainFolder as string, theSubFolder as string, theNote theHtmlBody as text)
-- getCompletedReminders(theSearchList as list, theCompletionStartDate as date, theCompletionEndDate as date)

-- This is the sorting routine I stole it from https://christianboyce.com/your-appointments-sir/
-- he found it on MacScripter.net.
-- on sortEvents(myList)

-- get the name of the current running script
-- stolen from post by mklement0 on stackoverflow
-- https://stackoverflow.com/questions/5770384/how-find-the-file-name-of-an-executing-applescript
-- getMyName()


use AppleScript version "2.8"
use scripting additions

on run
	-- Declare variables
	local yr
	local mn
	local dy
	local dateString
	local today
	
	-- initialise the variables
	set yr to missing value
	set mn to missing value
	set dy to missing value
	set dateString to missing value
	set today to missing value
	
	-- Set the date string to YYYY-MM-DD
	set {year:yr, month:mn, day:dy} to (current date)
	set dateString to (yr as text) & "-" & pad(mn as integer) & "-" & pad(dy)
	-- Set today's Date to current Date
	set today to current date
	-- set time to be the start time
	set time of today to 0
	
	-- Create the Additional partial note
	set theAdditionalNoteBody to AppendHtmlHeading(2, "Timesheets:", "")
	set theAdditionalNoteBody to AppendGeneratedInfo(theAdditionalNoteBody)
	
	
	-- Append theAdditionalNoteBody to the required note
	set theAdditionalNoteBody to getCompletedReminders("HPE", today, today + 86400, theAdditionalNoteBody)
	appendNote("iCloud", "HPE", "3. Journal", dateString & ": HPE Daily Log", theAdditionalNoteBody)
end run

on AppendGeneratedInfo(theHtmlText as text)
	local theNewHtmlText
	set theNewHtmlText to missing value
	
	set theNewHtmlText to theHtmlText & "Generated by " & getMyName() & " on " & (current date) & "<p>"
end AppendGeneratedInfo

--append an html heading to a text string
on AppendHtmlHeading(theHeadingType as integer, theHeadingString as string, theHtmlText)
	-- Declare variables
	
	-- Initialise the variables
	-- Append the additional heading to
	set theNewHtmlText to theHtmlText & "<p><h" & theHeadingType & ">" & theHeadingString & "</h" & theHeadingType & "><p>"
	return theNewHtmlText
end AppendHtmlHeading

-- append a value to a note
on appendNote(theAccount as string, theMainFolder as string, theSubFolder as string, theNote as string, theHtmlBody as text)
	tell application "Notes"
		tell account theAccount
			tell folder theMainFolder
				tell folder theSubFolder
					set theExistingHtml to get the body of note theNote
					-- append the theHtmlBody to the theNote
					set the body of note theNote to (theExistingHtml & theHtmlBody)
				end tell
			end tell
		end tell
	end tell
end appendNote

-- get completed Reminders within a requested period
on getCompletedReminders(theSearchStr, theCompletionStartDate as date, theCompletionEndDate as date, theHtmlBody as text)
	-- Declare variables
	local aReminder
	local theReminders
	local theHtmlBody
	local theSearchList
	
	--	initialise variables
	set aReminder to missing value
	set theReminders to missing value
	set theNewHtmlBody to missing value
	set theSearchList to missing value
	
	-- start the Unnumbered List
	set theNewHtmlBody to "<ul>" as text
	-- Get the list of completed Reminders
	tell application "Reminders"
		--	set theNames to the name of every reminder
		set theSearchList to list theSearchStr
		tell theSearchList
			-- get the list of completed reminders
			set the theReminders to (every reminder whose completed is true and completion date ≥ theCompletionStartDate and completion date ≤ theCompletionEndDate)
			-- with each reminder in theReinders 
			repeat with aReminder in theReminders
				set reminderText to name of aReminder as string
				set reminderBody to body of aReminder as text
				if reminderBody is missing value then
					set reminderBody to "no time recorded"
				end if
				-- If the reminderText is empty then it is useless putting it in here
				if reminderText is not missing value or reminderText is not "" then
					set theNewHtmlBody to theNewHtmlBody & "<li>" & reminderBody & ": " & reminderText & "</li>"
				end if
			end repeat
		end tell
	end tell
	-- close the Unnumber List
	set theNewHtmlBody to theHtmlBody & theNewHtmlBody & "</ul><p>"
	-- return the HTML Body to the caller
	return theNewHtmlBody
end getCompletedReminders

-- get the name of the current running script
-- stolen from post by mklement0 on stackoverflow
-- https://stackoverflow.com/questions/5770384/how-find-the-file-name-of-an-executing-applescript
on getMyName()
	local myName, tidSaved
	tell application "System Events"
		-- alias to the file/bundle of the running script
		set myAlias to path to me
		-- filename with extension, if any.
		set myName to name of myAlias
		-- strip away extension
		if name extension of myAlias is not "" then
			set {tidSaved, AppleScript's text item delimiters} to {AppleScript's text item delimiters, {""}}
			set myName to items 1 through -(2 + (length of (get name extension of myAlias))) of myName as text
			set AppleScript's text item delimiters to tidSaved
		end if
	end tell
	return myName
end getMyName

-- pad a number to have leading zeros
on pad(theInteger as integer)
	return text -2 thru -1 of ((theInteger + 100) as text)
end pad

-- This is the sorting routine I stole it from https://christianboyce.com/your-appointments-sir/
-- he found it on MacScripter.net.

on sortEvents(myList)
	set myNewList to {}
	repeat until length of myList = 0
		set leastIndex to findLeastItem(myList)
		set end of myNewList to item leastIndex of myList
		set myList to removeItemAtIndex(myList, leastIndex)
	end repeat
	return myNewList
end sortEvents

on findLeastItem(lst)
	tell application "Calendar"
		set theLeast to start date of item 1 of lst
		set theIndex to 1
		set iterater to 1
		repeat with i in lst
			if start date of i ≤ theLeast then
				set theLeast to start date of i
				set theIndex to iterater
			end if
			set iterater to iterater + 1
		end repeat
		
		return theIndex
	end tell
end findLeastItem

on removeItemAtIndex(lst, theIndex)
	set newList to {}
	set theLength to length of lst
	if theLength = 1 then
		set newList to {}
	else if theLength = theIndex then
		set newList to items 1 thru (theLength - 1) of lst
	else if theIndex = 1 then
		set newList to items 2 thru theLength of lst
	else
		set newList to items 1 thru (theIndex - 1) of lst & items (theIndex + 1) thru (theLength) of lst
	end if
	return newList
end removeItemAtIndex



