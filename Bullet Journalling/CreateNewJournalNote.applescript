--
--	Created by: Stephen Schwetz
--	Created on: 05/07/22
--
--	Copyright © 2022 Stephen Schwetz, All Rights Reserved
--

use AppleScript version "2.4" -- Yosemite (10.10) or later
use scripting additions

-- Versions
--  
-- 1.0 Build 0009: Fixed up Meeting list not containing all meetins
-- 1.0 Build 0002: Initial release

on run
	
	-- Set the date string to YYYY-MM-DD
	set {year:yr, month:mn, day:dy} to (current date)
	set dateString to (yr as text) & "-" & pad(mn as integer) & "-" & pad(dy)
	set today to current date
	set time of today to 0
	set tomorrow to (today) + 86400 -- seconds
	set theNoteBody to "<h1>" & dateString & ": Daily Log</h1>Generated by CreateNewJournalNote on " & (current date) & "<p><h2>Overdue / Due Task:</h2><ul>"
	-- set theNoteBody to "<h1>" & dateString & ": Daily Log</h1><div font-variant-position: sub>Generated by CreateNewJournalNote by Stephen Schwetz</div><div font-variant-position: super>Generated at " & (current date) & "</div><p><h2>Overdue / Due Task:</h2><p><ul>"
	set theNoteBody2 to "<p><h2>To Do:</h2><p><ul>"
	
	-- Get the list of outstanding Reminders
	tell application "Reminders"
		set myList to list "HPE"
		--	set theNames to the name of every reminder
		tell myList
			set the theReminders to (every reminder whose completed is not true)
			repeat with aReminder in theReminders
				--if aReminder is not "completed" then
				set aduedate to due date of aReminder
				set apriority to priority of aReminder
				-- if overdue today add to Due/OverDue and make it red to stand out
				if (aduedate < today) then
					-- is this a high priority job?
					if apriority = 0 then
						set theReminderPriority to "-"
					else if apriority ≥ 1 and apriority ≤ 4 then
						set theReminderPriority to "!!"
					else if apriority is 5 then
						set theReminderPriority to "!"
					else if apriority ≥ 6 and apriority ≤ 9 then
						set theReminderPriority to "¡¡"
					end if
					
					set reminderText to name of aReminder as string
					set theNoteBody to theNoteBody & "<li style=\"color:red\">" & theReminderPriority & " " & reminderText & "</li>"
					-- if due today
				else if (aduedate > today and aduedate < tomorrow) then
					set reminderText to name of aReminder as string
					set theNoteBody to theNoteBody & "<li>" & reminderText & "</li>"
					-- this is a general todo item
				else
					set reminderText to name of aReminder as string
					set theNoteBody2 to theNoteBody2 & "<li> " & reminderText & "</li>"
				end if
			end repeat
		end tell
	end tell
	
	set theNoteBody to theNoteBody & "</ul>" & theNoteBody2 & "</ul><p>"
	
	
	-- Get the Calendar Items for Today
	set theNoteBody to theNoteBody & "</ul><p><h2>Meetings:</h2>" as text
	-- Use following Calendars
	set the_calendar_list to {"Calendar", "Family", "Stephen's Calendar", "Stephen and Emma"}
	
	-- set the lists to have sqaure just to be different from the todo lists
	set theAllDayEvents to "" as string
	set theGeneralEvents to "" as string
	set theAllDayEventCounter to 0 as integer
	set theGeneralEventsCounter to 0 as integer
	
	-- set today to start at midnight
	set time of today to 0
	set tomorrow to (today) + 86400 -- seconds
	tell application "Calendar"
		set the_calendars to {}
		set every_calendar to every calendar
		-- Now we have a list of calendars to check.
		theGeneralEventsCounter is 0
		theAllDayEventCounter is 0
		repeat with an_item in the_calendar_list
			set end of the_calendars to (first calendar whose name is an_item)
		end repeat
		-- Now we check, on a calendar by calendar basis, for appointments on the current day.
		repeat with a_calendar in the_calendars
			tell a_calendar
				-- We need to get a list of events from the calendar, but we want to make it so that it will only return items that happen today
				-- the due date is today is to capture all day events.
				set the_events to (every event whose (start date ≥ today and end date ≤ tomorrow))
				--
				-- Here we sort the list of events for the day. If we don’t do this they won’t be chronological. iCal sorts them in creation order unless we run this little "sortEvents" routine.
				--
				set the_events to my sortEvents(the_events)
				-- Now we have a sorted list. Let’s create a string for the Mac to speak. Loop through the events and make that string.
				repeat with an_event in the_events
					set allday_event to allday event of an_event
					set x to properties of an_event
					set the_summary to summary of an_event
					set the_start_date to start date of an_event
					set the_end_date to end date of an_event
					set the_start_time to time string of the_start_date
					set the_end_time to time string of the_end_date
					
					-- if this is an allday event we will add it to a seperate list so that we can put it at the top of the list with a different format
					if allday_event then
						if theAllDayEventCounter is 0 then
							set theAllDayEvents to "<ul>"
							set theAllDayEventCounter to 1
						end if
						set theAllDayEvents to theAllDayEvents & "<li>" & the_summary & "</li>"
					else
						-- this is a standard event
						-- if this is the first iteration of this type
						if theGeneralEventsCounter is 0 then
							-- Create and unumbered List
							set theGeneralEvents to "<ul>"
							set theGeneralEventsCounter to 1
						end if
						-- increment the counter
						
						set theGeneralEvents to theGeneralEvents & "<li>" & the_start_time & " to " & the_end_time & " - " & the_summary & "</li>"
					end if
				end repeat
			end tell
		end repeat
		-- add the events to the NoteBody
		set theNoteBody to theNoteBody & theAllDayEvents & "</ul>" & theGeneralEvents & "</ul>"
	end tell
	
	set theNoteBody to theNoteBody & "<p><h2>Job Notes:</h2><p>"
	
	tell application "Notes"
		tell account "icloud"
			tell folder "HPE"
				try
					set theNote to make new note at folder "3. Journal" with properties {name:dateString & ": HPE Daily Log", body:theNoteBody}
					show theNote
				end try
			end tell
		end tell
	end tell
	
end run

on pad(v)
	return text -2 thru -1 of ((v + 100) as text)
end pad

-- This is the sorting routine for the CalendarI stole it from https://christianboyce.com/your-appointments-sir/
-- he found it on MacScripter.net.

on findLeastItem(lst)
	tell application "Calendar"
		set theLeast to start date of item 1 of lst
		set theIndex to 1
		set iterater to 1
		repeat with i in lst
			if start date of i ≤ theLeast then
				set theLeast to start date of i
				set theIndex to iterater
			end if
			set iterater to iterater + 1
		end repeat
		
		return theIndex
	end tell
end findLeastItem

on removeItemAtIndex(lst, theIndex)
	set newList to {}
	set theLength to length of lst
	if theLength = 1 then
		set newList to {}
	else if theLength = theIndex then
		set newList to items 1 thru (theLength - 1) of lst
	else if theIndex = 1 then
		set newList to items 2 thru theLength of lst
	else
		set newList to items 1 thru (theIndex - 1) of lst & items (theIndex + 1) thru (theLength) of lst
	end if
	return newList
end removeItemAtIndex

on sortEvents(myList)
	set myNewList to {}
	repeat until length of myList = 0
		set leastIndex to findLeastItem(myList)
		set end of myNewList to item leastIndex of myList
		set myList to removeItemAtIndex(myList, leastIndex)
	end repeat
	return myNewList
end sortEvents
